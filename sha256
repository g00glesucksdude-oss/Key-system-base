-- SHA-256 Module (Executor-Safe, Loadstring-Compatible)
return function()
	local bit = bit32
	local function rrotate(x, n)
		return bit.rrotate(x, n)
	end

	local function to_bytes(str)
		local bytes = {}
		for i = 1, #str do
			bytes[#bytes + 1] = string.byte(str, i)
		end
		return bytes
	end

	local function pad(bytes)
		local len = #bytes * 8
		bytes[#bytes + 1] = 0x80
		while (#bytes % 64) ~= 56 do
			bytes[#bytes + 1] = 0
		end
		for i = 56, 63 do
			bytes[#bytes + 1] = bit.rshift(len, (63 - i) * 8) % 256
		end
		return bytes
	end

	local function to_words(bytes)
		local words = {}
		for i = 1, #bytes, 4 do
			local word = bit.lshift(bytes[i], 24) + bit.lshift(bytes[i+1], 16) + bit.lshift(bytes[i+2], 8) + bytes[i+3]
			words[#words + 1] = word
		end
		return words
	end

	local function compress(chunk, H)
		local K = {
			0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
			0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
			0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
			0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
			0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
			0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
			0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
			0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2
		}

		local w = {}
		for i = 1, 16 do
			w[i] = chunk[i]
		end
		for i = 17, 64 do
			local s0 = bit.bxor(rrotate(w[i-15], 7), rrotate(w[i-15], 18), bit.rshift(w[i-15], 3))
			local s1 = bit.bxor(rrotate(w[i-2], 17), rrotate(w[i-2], 19), bit.rshift(w[i-2], 10))
			w[i] = (w[i-16] + s0 + w[i-7] + s1) % 4294967296
		end

		local a, b, c, d, e, f, g, h = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]
		for i = 1, 64 do
			local S1 = bit.bxor(rrotate(e, 6), rrotate(e, 11), rrotate(e, 25))
			local ch = bit.bxor(bit.band(e, f), bit.band(bit.bnot(e), g))
			local temp1 = (h + S1 + ch + K[i] + w[i]) % 4294967296
			local S0 = bit.bxor(rrotate(a, 2), rrotate(a, 13), rrotate(a, 22))
			local maj = bit.bxor(bit.band(a, b), bit.band(a, c), bit.band(b, c))
			local temp2 = (S0 + maj) % 4294967296

			h = g
			g = f
			f = e
			e = (d + temp1) % 4294967296
			d = c
			c = b
			b = a
			a = (temp1 + temp2) % 4294967296
		end

		H[1] = (H[1] + a) % 4294967296
		H[2] = (H[2] + b) % 4294967296
		H[3] = (H[3] + c) % 4294967296
		H[4] = (H[4] + d) % 4294967296
		H[5] = (H[5] + e) % 4294967296
		H[6] = (H[6] + f) % 4294967296
		H[7] = (H[7] + g) % 4294967296
		H[8] = (H[8] + h) % 4294967296
	end

	local function sha256(input)
		assert(type(input) == "string", "Input must be a string")
		local bytes = pad(to_bytes(input))
		local words = to_words(bytes)
		local H = {
			0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,
			0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19
		}
		for i = 1, #words, 16 do
			local chunk = {}
			for j = 0, 15 do
				chunk[j+1] = words[i+j]
			end
			compress(chunk, H)
		end
		local digest = ""
		for i = 1, 8 do
			digest = digest .. string.format("%08x", H[i])
		end
		return digest
	end

	return sha256
end
