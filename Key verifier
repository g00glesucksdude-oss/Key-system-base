local salt = "monkey"
local nonceFile = ".used_keys.txt"

-- 🔧 GUI Setup
local player = game:GetService("Players").LocalPlayer
local gui = Instance.new("ScreenGui", player:WaitForChild("PlayerGui"))
gui.Name = "KeyVerifier"

local inputBox = Instance.new("TextBox", gui)
inputBox.Name = "InputBox"
inputBox.PlaceholderText = "Paste your key here"
inputBox.Size = UDim2.new(0, 300, 0, 40)
inputBox.Position = UDim2.new(0.5, -150, 0.4, 0)
inputBox.Text = ""

local verifyButton = Instance.new("TextButton", gui)
verifyButton.Name = "VerifyButton"
verifyButton.Text = "Verify Key"
verifyButton.Size = UDim2.new(0, 150, 0, 40)
verifyButton.Position = UDim2.new(0.5, -75, 0.5, 0)

local outputLabel = Instance.new("TextLabel", gui)
outputLabel.Name = "OutputLabel"
outputLabel.TextWrapped = true
outputLabel.Size = UDim2.new(0, 400, 0, 100)
outputLabel.Position = UDim2.new(0.5, -200, 0.6, 0)
outputLabel.Text = ""

-- 🔧 Helpers
local function toHex(str)
	return (str:gsub(".", function(c)
		return string.format("%02x", string.byte(c))
	end))
end

local function b64decode(data)
	local b64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
	local lookup = {}
	for i = 1, #b64chars do lookup[b64chars:sub(i, i)] = i - 1 end
	data = data:gsub("[^" .. b64chars .. "=]", "")
	local bytes = {}

	for i = 1, #data, 4 do
		local c1 = lookup[data:sub(i, i)] or 0
		local c2 = lookup[data:sub(i + 1, i + 1)] or 0
		local c3 = lookup[data:sub(i + 2, i + 2)] or 0
		local c4 = lookup[data:sub(i + 3, i + 3)] or 0

		local b1 = c1 * 4 + math.floor(c2 / 16)
		table.insert(bytes, string.char(b1))

		if data:sub(i + 2, i + 2) ~= "" then
			local b2 = (c2 % 16) * 16 + math.floor(c3 / 4)
			table.insert(bytes, string.char(b2))
		end

		if data:sub(i + 3, i + 3) ~= "" then
			local b3 = (c3 % 4) * 64 + c4
			table.insert(bytes, string.char(b3))
		end
	end

	return table.concat(bytes)
end

local function cleanInput(str)
	return str:gsub("[%z\1-\31\127-\255]", ""):gsub("^%s*(.-)%s*$", "%1")
end

-- 🔐 HMAC stub (replace with real logic if needed)
local function sha256_hmac(data, key)
	local fake = "deadbeefcafebabe" .. tostring(#data + #key)
	return fake:rep(4):sub(1, 64)
end

-- 🧾 Nonce tracking
local function hasUsedNonce(nonce)
	if not isfile(nonceFile) then return false end
	local content = readfile(nonceFile)
	return content:find(nonce, 1, true) ~= nil
end

local function markNonceUsed(nonce)
	appendfile(nonceFile, nonce .. "\n")
end

-- ✅ Key validator
local function validateKey(encodedKey)
	local key = cleanInput(encodedKey)
	local decoded = b64decode(key)
	local parts = string.split(decoded, "|")
	if #parts ~= 3 then
		outputLabel.Text = "❌ Invalid key format"
		return
	end

	local expiry = tonumber(parts[1])
	local nonce = parts[2]
	local hash = parts[3]

	if not expiry or not nonce or not hash then
		outputLabel.Text = "❌ Malformed key"
		return
	end

	if hasUsedNonce(nonce) then
		outputLabel.Text = "❌ Rejected: key already used"
		return
	end

	local raw = expiry .. "|" .. nonce
	local expected = sha256_hmac(raw, salt)

	if expected == hash then
		markNonceUsed(nonce)
		local remaining = expiry - os.time()
		local status = remaining > 0 and "✅ Valid key" or "⚠️ Expired but untampered"
		outputLabel.Text = string.format(
			"%s\n🕒 Expiry: %s\n⏳ Remaining: %d seconds\n🔁 Nonce: %s",
			status,
			os.date("%Y-%m-%d %H:%M:%S", expiry),
			remaining,
			nonce
		)
	else
		outputLabel.Text = "❌ Tampered or invalid key"
	end
end

verifyButton.MouseButton1Click:Connect(function()
	validateKey(inputBox.Text)
end)
