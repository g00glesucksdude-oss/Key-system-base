local CONFIG = {
    salt = "secret_salt",
    xor_shift = 7,
    header = "GGL-sandbox",
    split_char = "|",
    execute_payload = true,
    signal_expiry = true,
    validfor = 60, -- seconds
    varexpiry = "myexpiry",
    varpayload = "mypayload",
    varexpired = "myexpired",
    varisexpired = "is_expired"
}

-- Load SHA-256 implementation from your repo
loadstring(game:HttpGet("https://raw.githubusercontent.com/g00glesucksdude-oss/Key-system-base/refs/heads/main/sha256"))()
-- Now sha256() is available globally

-- XOR deobfuscation
local function xor_deobfuscate(data, salt, shift)
    local result = {}
    for i = 1, #data do
        local key = string.byte(salt:sub((i - 1) % #salt + 1)) ~ shift
        result[i] = string.char(string.byte(data:sub(i, i)) ~ key)
    end
    return table.concat(result)
end

-- Replay protection
local function nonce_used(nonce)
    local path = "used_nonces.txt"
    if not isfile or not readfile or not writefile then
        return false -- skip if file APIs not supported
    end
    if not isfile(path) then writefile(path, "") end
    local content = readfile(path) or ""
    for line in string.gmatch(content, "[^\r\n]+") do
        if line == nonce then return true end
    end
    return false
end

local function mark_nonce_used(nonce)
    if appendfile then
        appendfile("used_nonces.txt", nonce .. "\n")
    end
end

-- Load GUI
local gui = loadstring(game:HttpGet("https://raw.githubusercontent.com/g00glesucksdude-oss/Complicated-key-system/main/gui"))()
local textbox, button, label = gui.TextBox, gui.Button, gui.Label

-- Validation logic
button.MouseButton1Click:Connect(function()
    local input = textbox.Text
    if not input or input == "" then
        label.Text = "Enter a key"
        return
    end

    local decrypted = xor_deobfuscate(input, CONFIG.salt, CONFIG.xor_shift)
    local parts = string.split(decrypted, CONFIG.split_char)
    if #parts ~= 6 or parts[1] ~= CONFIG.header then
        label.Text = "Invalid format"
        return
    end

    local validfor = tonumber(parts[2])
    local expiresat = tonumber(parts[3])
    local payload = parts[4]
    local nonce = parts[5]
    local digest = parts[6]

    if not validfor or not expiresat or not nonce or not digest then
        label.Text = "Malformed key fields"
        return
    end

    if validfor ~= CONFIG.validfor then
        label.Text = "Invalid validity window"
        return
    end

    -- Compute expected digest with your sha256
    local concat = tostring(validfor)
        .. CONFIG.split_char .. tostring(expiresat)
        .. CONFIG.split_char .. payload
        .. CONFIG.split_char .. nonce
        .. CONFIG.split_char .. CONFIG.salt

    local expected = sha256(concat)
    if (digest or ""):lower() ~= (expected or ""):lower() then
        label.Text = "Digest mismatch"
        return
    end

    if nonce_used(nonce) then
        label.Text = "Replay detected"
        return
    end
    mark_nonce_used(nonce)

    -- Inject globals
    getgenv()[CONFIG.varexpiry] = expiresat
    getgenv()[CONFIG.varpayload] = payload
    getgenv()[CONFIG.varexpired] = false
    getgenv()[CONFIG.varisexpired] = function()
        return os.time() >= getgenv()[CONFIG.varexpiry]
    end

    -- Countdown updater
    task.spawn(function()
        while true do
            task.wait(1)
            local left = getgenv()[CONFIG.varexpiry] - os.time()
            if left <= 0 then
                getgenv()[CONFIG.varexpired] = true
                label.Text = "Key expired"
                break
            else
                label.Text = "Time left: " .. left .. "s"
            end
        end
    end)

    -- Execute payload if valid
    if not getgenv()[CONFIG.varisexpired]() and CONFIG.execute_payload then
        local ok, err = pcall(function()
            loadstring(getgenv()[CONFIG.varpayload])()
        end)
        if not ok then
            label.Text = "Payload error: " .. tostring(err)
        end
    end
end)
